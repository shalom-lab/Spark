[
  {
    "id": "1769266734241",
    "title": "Githubæƒé™",
    "lang": "JS",
    "code": "import { Octokit } from \"@octokit/rest\";\n\nexport async function verifyGitHubAccessSimple(\n  repo: string,\n  token: string\n): Promise<{ defaultBranch: string; canRead: boolean; canWrite: boolean }> {\n  // å‚æ•°æ ¡éªŒï¼šowner/repo ä¸”éç©º\n  const parts = String(repo).split(\"/\").map(s => s.trim()).filter(Boolean);\n  if (parts.length !== 2) throw new Error('ä»“åº“æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º \"owner/repo\"');\n\n  const [owner, repoName] = parts;\n  if (!token || !token.trim()) throw new Error(\"ç¼ºå°‘ token\");\n\n  const octokit = new Octokit({ auth: token });\n\n  try {\n    const { data } = await octokit.rest.repos.get({ owner, repo: repoName });\n    const defaultBranch = data.default_branch ?? \"main\";\n\n    // ä¼˜å…ˆç”¨ data.permissionsï¼ˆå¦‚æœæœ‰ï¼‰\n    if (data.permissions) {\n      return {\n        defaultBranch,\n        canRead: Boolean(data.permissions.pull),\n        canWrite: Boolean(data.permissions.push || data.permissions.admin),\n      };\n    }\n\n    // å›é€€ç­–ç•¥ï¼ˆç®€æ´ç‰ˆï¼‰ï¼š\n    // 1) ç”¨ä¸€æ¬¡å®‰å…¨çš„åªè¯»è¯·æ±‚ç¡®è®¤ read èƒ½åŠ›\n    let canRead = false;\n    try {\n      await octokit.rest.repos.listBranches({ owner, repo: repoName, per_page: 1 });\n      canRead = true;\n    } catch {\n      canRead = false;\n    }\n\n    // 2) è‹¥èƒ½æ‹¿åˆ° authenticated userï¼Œåˆ™ä¿å®ˆæ¨æ–­ write\n    let canWrite = false;\n    try {\n      const me = await octokit.rest.users.getAuthenticated();\n      const username = me.data.login;\n      if (username) {\n        const perm = await octokit.rest.repos.getCollaboratorPermissionLevel({\n          owner,\n          repo: repoName,\n          username,\n        });\n        const level = perm.data.permission; // \"admin\" | \"write\" | \"read\" | \"none\"\n        canWrite = level === \"admin\" || level === \"write\";\n      }\n    } catch {\n      // æ— æ³•è·å– authenticated user æˆ–æƒé™æ¥å£å¤±è´¥ -> ä¿å®ˆè®¤ä¸ºä¸å¯å†™\n      canWrite = false;\n    }\n\n    return { defaultBranch, canRead, canWrite };\n  } catch (err: any) {\n    const status = err?.status || err?.response?.status;\n    if (status === 401) throw new Error(\"Token æ— æ•ˆæˆ–å·²è¿‡æœŸï¼ˆ401ï¼‰\");\n    if (status === 403) throw new Error(\"Token æƒé™ä¸è¶³æˆ–è¢«ç¦æ­¢ï¼ˆ403ï¼‰ã€‚å¯¹äºç»†ç²’åº¦ tokenï¼Œè¯·æ£€æŸ¥æ˜¯å¦ä¸ºè¯¥ä»“åº“æˆæƒã€‚\");\n    if (status === 404) throw new Error(\"ä»“åº“ä¸å­˜åœ¨æˆ– Token æœªè¢«æˆæƒè®¿é—®è¯¥ä»“åº“ï¼ˆ404ï¼‰\");\n    throw new Error(`éªŒè¯å¤±è´¥: ${err?.message ?? \"æœªçŸ¥é”™è¯¯\"}`);\n  }\n}",
    "tags": [
      "Github",
      "readwrite"
    ],
    "createdAt": 1769266734241
  },
  {
    "id": "1769353733808",
    "title": "Zotero",
    "lang": "SQL",
    "code": "WITH RECURSIVE ancestors(itemID) AS (\n  SELECT i.itemID\n  FROM items i\n  WHERE i.itemTypeID = 3   -- attachment\n  -- å¯æ”¹æˆåªæŸ¥ä¸€ä¸ªç‰¹å®š key\n  UNION ALL\n  SELECT ia.parentItemID\n  FROM itemAttachments ia\n  JOIN ancestors a ON ia.itemID = a.itemID\n  WHERE ia.parentItemID IS NOT NULL\n  UNION ALL\n  SELECT inote.parentItemID\n  FROM itemNotes inote\n  JOIN ancestors a ON inote.itemID = a.itemID\n)\nSELECT i.key AS ParentKey,\n       MAX(CASE WHEN f.fieldName='title' THEN idv.value END) AS title,\n       MAX(CASE WHEN f.fieldName='abstractNote' THEN idv.value END) AS abstract,\n       MAX(CASE WHEN f.fieldName='publicationTitle' THEN idv.value END) AS journal,\n       MAX(CASE WHEN f.fieldName='date' THEN idv.value END) AS date,\n       (SELECT GROUP_CONCAT(c.lastName || ', ' || c.firstName, '; ')\n        FROM itemCreators ic JOIN creators c ON ic.creatorID=c.creatorID\n        WHERE ic.itemID=i.itemID\n        ORDER BY ic.orderIndex) AS authors,\n       (SELECT GROUP_CONCAT(t.name,'; ')\n        FROM itemTags it JOIN tags t ON it.tagID=t.tagID\n        WHERE it.itemID=i.itemID) AS keywords\nFROM ancestors a\nJOIN items i ON i.itemID=a.itemID\nLEFT JOIN itemData id ON id.itemID=i.itemID\nLEFT JOIN fields f ON id.fieldID=f.fieldID\nLEFT JOIN itemDataValues idv ON id.valueID=idv.valueID\nWHERE i.itemTypeID NOT IN (3,40)\nGROUP BY i.key;\n",
    "tags": [
      "zotero"
    ],
    "createdAt": 1769353733808
  },
  {
    "id": "1769408828549",
    "title": "Zotero",
    "lang": "JS",
    "code": "(async function() {\n\n    const SEARCH_NAME = 'é‡å¤æ¡ç›® (_dup)';\n\n    // è·å–å½“å‰ä¸ªäººåº“çš„ ID\n\n    const libID = Zotero.Libraries.userLibraryID;\n\n\n\n    // ä¿®å¤ç‚¹ï¼šä¼ å…¥ libIDï¼Œè§£å†³ SQL å ä½ç¬¦æŠ¥é”™\n\n    let allSearches = await Zotero.Searches.getAll(libID);\n\n    \n\n    let foundSearch = allSearches.find(s => s.getName() === SEARCH_NAME);\n\n\n\n    if (foundSearch) {\n\n        console.log(`ğŸ” æ‰¾åˆ° Key: ${foundSearch.key}`);\n\n        \n\n        // æ‰§è¡Œç‰©ç†åˆ é™¤\n\n        await foundSearch.eraseTx();\n\n        \n\n        // åˆ·æ–° UI\n\n        if (typeof ZoteroPane !== 'undefined') {\n\n            ZoteroPane.collectionsView.refresh();\n\n        }\n\n        \n\n        return `æˆåŠŸåˆ é™¤: ${SEARCH_NAME}`;\n\n    } else {\n\n        return \"æœªæ‰¾åˆ°è¯¥æœç´¢åˆ†ç±»\";\n\n    }\n\n})();",
    "tags": [
      "åˆ é™¤æœç´¢"
    ],
    "createdAt": 1769408828549
  },
  {
    "id": "1769409003917",
    "title": "Zotero",
    "lang": "JS",
    "code": "(async function() {\n    const searchName = 'é‡å¤æ¡ç›® (_dup)';\n    const targetTag = '_dup'; // æ ¹æ®ä½ ä¹‹å‰çš„æè¿°ï¼Œè¿™é‡Œè®¾ä¸º _dupï¼Œå¦‚æœæ˜¯ '_tag' è¯·è‡ªè¡Œä¿®æ”¹\n    const libraryID = Zotero.Libraries.userLibraryID;\n\n    // 1. åˆ›å»ºæœç´¢å¯¹è±¡\n    let s = new Zotero.Search();\n    s.libraryID = libraryID;\n    s.setName(searchName);\n\n    // 2. æ·»åŠ æœç´¢æ¡ä»¶ï¼šæ ‡ç­¾ (tag) æ˜¯ (is) æŒ‡å®šå€¼\n    // ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å­—æ®µåï¼Œç¬¬äºŒä¸ªæ˜¯è¿ç®—ç¬¦ï¼Œç¬¬ä¸‰ä¸ªæ˜¯å€¼\n    s.addCondition('tag', 'is', targetTag);\n\n    // 3. æ‰§è¡Œä¿å­˜äº‹åŠ¡\n    // eraseTx æ˜¯åˆ é™¤ï¼ŒsaveTx æ˜¯ä¿å­˜ï¼ˆå¸¦æ•°æ®åº“äº‹åŠ¡æ”¯æŒï¼‰\n    try {\n        let searchID = await s.saveTx();\n        \n        // 4. å¼ºåˆ¶åˆ·æ–°ç•Œé¢ï¼Œè®©æ–°æœç´¢å‡ºç°åœ¨å·¦ä¾§è¾¹æ \n        if (typeof ZoteroPane !== 'undefined') {\n            await ZoteroPane.collectionsView.refresh();\n            // è‡ªåŠ¨é€‰ä¸­æ–°ç”Ÿæˆçš„æœç´¢\n            ZoteroPane.collectionsView.selectSearch(searchID);\n        }\n        \n        return `æˆåŠŸåˆ›å»ºæœç´¢åˆ†ç±»ï¼š${searchName} (ID: ${searchID})`;\n    } catch (e) {\n        return `åˆ›å»ºå¤±è´¥ï¼š${e.message}`;\n    }\n})();",
    "tags": [
      "æ–°å»ºæœç´¢"
    ],
    "createdAt": 1769409003917
  },
  {
    "id": "1769409183885",
    "title": "Zotero",
    "lang": "JS",
    "code": "(async function() {\n    const TAG_NAME = '_dup';\n    const libID = Zotero.Libraries.userLibraryID;\n\n    // 1. æŸ¥æ‰¾æ‰€æœ‰å¸¦æœ‰è¯¥æ ‡ç­¾çš„æ¡ç›®\n    var s = new Zotero.Search();\n    s.libraryID = libID;\n    s.addCondition('tag', 'is', TAG_NAME);\n    var ids = await s.search();\n\n    if (!ids.length) {\n        return \"æœªå‘ç°å¸¦æœ‰ \" + TAG_NAME + \" æ ‡ç­¾çš„æ¡ç›®ã€‚\";\n    }\n\n    console.log(`æ­£åœ¨ä» ${ids.length} ä¸ªæ¡ç›®ä¸­ç§»é™¤æ ‡ç­¾...`);\n\n    // 2. ä½¿ç”¨æ•°æ®åº“äº‹åŠ¡æ‰¹é‡å¤„ç†ï¼Œæé«˜æ€§èƒ½å¹¶ç¡®ä¿å®‰å…¨\n    await Zotero.DB.executeTransaction(async function () {\n        for (let id of ids) {\n            let item = Zotero.Items.get(id);\n            \n            // 3. ç§»é™¤æ ‡ç­¾\n            item.removeTag(TAG_NAME);\n            \n            // 4. ä¿å­˜æ›´æ”¹\n            // ä½¿ç”¨ skipDateModifiedUpdate: true å¯ä»¥é˜²æ­¢åŒæ­¥æ—¶å› ä¿®æ”¹æ—¶é—´å˜åŠ¨å¯¼è‡´çš„å†²çª\n            await item.save({\n                skipDateModifiedUpdate: true\n            });\n        }\n    });\n\n    // 5. åˆ·æ–° UI ç•Œé¢\n    if (typeof ZoteroPane !== 'undefined') {\n        ZoteroPane.collectionsView.refresh();\n    }\n\n    return `æˆåŠŸç§»é™¤ ${ids.length} ä¸ªæ¡ç›®ä¸Šçš„ \"${TAG_NAME}\" æ ‡ç­¾ã€‚`;\n})();",
    "tags": [
      "ç§»é™¤tag"
    ],
    "createdAt": 1769409183885
  },
  {
    "id": "1769409834831",
    "title": "Zotero",
    "lang": "JS",
    "code": "(async function() {\n    const DUP_TAG = '_dup';\n    const SAVED_SEARCH_NAME = 'é‡å¤æ¡ç›® (_dup)';\n    const libID = Zotero.Libraries.userLibraryID;\n    \n    console.log('ğŸ“¦ [å¯åŠ¨] æ­£åœ¨è¿›è¡Œ DOI æ·±åº¦æ¯”å¯¹å»é‡...');\n\n    // 1. è·å–æ‰€æœ‰å« DOI çš„æ¡ç›®\n    let s = new Zotero.Search();\n    s.libraryID = libID;\n    s.addCondition('DOI', 'isNot', '');\n    let ids = await s.search();\n    \n    if (ids.length === 0) return \"âŒ åº“ä¸­æœªå‘ç°å«æœ‰ DOI çš„æ¡ç›®\";\n    console.log(`âœ… æ£€ç´¢åˆ° ${ids.length} æ¡å« DOI çš„è®°å½•ï¼Œæ­£åœ¨æ‹‰å–è¯¦ç»†æ•°æ®...`);\n\n    // 2. æ‰¹é‡æ‹‰å–æ•°æ®å¹¶æ¸…æ´—æ ¼å¼\n    let doiMap = new Map();\n    let items = await Zotero.Items.getAsync(ids);\n\n    for (let item of items) {\n        if (!item.isRegularItem()) continue; // æ’é™¤é™„ä»¶å’Œç¬”è®°\n        \n        let rawDoi = item.getField('DOI');\n        if (!rawDoi) continue;\n\n        // å¼ºåŠ›æ¸…æ´— DOI æ ¼å¼ï¼šè½¬å°å†™ã€å» URL å‰ç¼€ã€å»åç¼€æ–œæ \n        let cleanDoi = rawDoi.toLowerCase().trim()\n                        .replace(/^https?:\\/\\/doi\\.org\\//, \"\")\n                        .replace(/^doi:/, \"\")\n                        .replace(/\\/$/, \"\")\n                        .trim();\n        \n        if (!doiMap.has(cleanDoi)) doiMap.set(cleanDoi, []);\n        doiMap.get(cleanDoi).push(item);\n    }\n\n    // 3. ç­›é€‰å‡ºå­˜åœ¨é‡å¤çš„ç»„\n    let duplicateGroups = Array.from(doiMap.entries()).filter(([doi, arr]) => arr.length > 1);\n    console.log(`ğŸ“Š å‘ç° ${duplicateGroups.length} ç»„ DOI é‡å¤ã€‚å¼€å§‹æŒ‰ç­–ç•¥æ ‡è®°...`);\n\n    let processedGroups = 0;\n    let taggedItemsCount = 0;\n\n    for (let [doi, group] of duplicateGroups) {\n        // ç­–ç•¥ï¼š1.ä¼˜å…ˆä¿ç•™æœ‰é™„ä»¶çš„ 2.å…¶æ¬¡ä¿ç•™æœ€æ—©æ·»åŠ çš„\n        group.sort((a, b) => {\n            let attA = a.getAttachments().length > 0 ? 1 : 0;\n            let attB = b.getAttachments().length > 0 ? 1 : 0;\n            if (attA !== attB) return attB - attA; // æœ‰é™„ä»¶çš„æ’åœ¨å‰é¢\n            return new Date(a.dateAdded) - new Date(b.dateAdded); // å…¶æ¬¡é€‰æœ€æ—©çš„\n        });\n\n        // ç¬¬ä¸€æ¡ä½œä¸º \"Keep\"ï¼Œå…¶ä½™æ‰“æ ‡ç­¾\n        for (let i = 1; i < group.length; i++) {\n            let itemToTag = group[i];\n            if (!itemToTag.hasTag(DUP_TAG)) {\n                itemToTag.addTag(DUP_TAG);\n                await itemToTag.saveTx({ skipDateModifiedUpdate: true });\n                taggedItemsCount++;\n            }\n        }\n        \n        processedGroups++;\n        \n        // æ¯å¤„ç† 50 ç»„æ‰“å°ä¸€æ¬¡è¿›åº¦\n        if (processedGroups % 50 === 0) {\n            console.log(`â³ å·²æ£€æŸ¥ ${processedGroups} / ${duplicateGroups.length} ç»„... (å½“å‰å·²æ ‡è®° ${taggedItemsCount} æ¡)`);\n        }\n    }\n\n    // 4. åˆ›å»ºæˆ–æ›´æ–° Saved Search (Zotero 7 ä¿®æ­£ç‰ˆ)\n    let allSearches = await Zotero.Searches.getAll(libID);\n    let existingSearch = allSearches.find(s => s.getName() === SAVED_SEARCH_NAME);\n    \n    if (!existingSearch) {\n        let ss = new Zotero.Search();\n        ss.libraryID = libID;\n        ss.setName(SAVED_SEARCH_NAME);\n        ss.addCondition('tag', 'is', DUP_TAG);\n        await ss.saveTx();\n        console.log(`ğŸ“ è‡ªåŠ¨åˆ†ç±»å·²åˆ›å»º: ${SAVED_SEARCH_NAME}`);\n    }\n\n    console.log(`ğŸ [å®Œæˆ] å¤„ç†äº† ${processedGroups} ç»„é‡å¤ï¼Œå…±è®¡æ ‡è®°æ¡ç›®: ${taggedItemsCount}`);\n\n})();",
    "tags": [
      "doiå»é‡"
    ],
    "createdAt": 1769409834831
  }
]