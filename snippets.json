[
  {
    "id": "1769266734241",
    "title": "Github权限",
    "lang": "JS",
    "code": "import { Octokit } from \"@octokit/rest\";\n\nexport async function verifyGitHubAccessSimple(\n  repo: string,\n  token: string\n): Promise<{ defaultBranch: string; canRead: boolean; canWrite: boolean }> {\n  // 参数校验：owner/repo 且非空\n  const parts = String(repo).split(\"/\").map(s => s.trim()).filter(Boolean);\n  if (parts.length !== 2) throw new Error('仓库格式错误，应为 \"owner/repo\"');\n\n  const [owner, repoName] = parts;\n  if (!token || !token.trim()) throw new Error(\"缺少 token\");\n\n  const octokit = new Octokit({ auth: token });\n\n  try {\n    const { data } = await octokit.rest.repos.get({ owner, repo: repoName });\n    const defaultBranch = data.default_branch ?? \"main\";\n\n    // 优先用 data.permissions（如果有）\n    if (data.permissions) {\n      return {\n        defaultBranch,\n        canRead: Boolean(data.permissions.pull),\n        canWrite: Boolean(data.permissions.push || data.permissions.admin),\n      };\n    }\n\n    // 回退策略（简洁版）：\n    // 1) 用一次安全的只读请求确认 read 能力\n    let canRead = false;\n    try {\n      await octokit.rest.repos.listBranches({ owner, repo: repoName, per_page: 1 });\n      canRead = true;\n    } catch {\n      canRead = false;\n    }\n\n    // 2) 若能拿到 authenticated user，则保守推断 write\n    let canWrite = false;\n    try {\n      const me = await octokit.rest.users.getAuthenticated();\n      const username = me.data.login;\n      if (username) {\n        const perm = await octokit.rest.repos.getCollaboratorPermissionLevel({\n          owner,\n          repo: repoName,\n          username,\n        });\n        const level = perm.data.permission; // \"admin\" | \"write\" | \"read\" | \"none\"\n        canWrite = level === \"admin\" || level === \"write\";\n      }\n    } catch {\n      // 无法获取 authenticated user 或权限接口失败 -> 保守认为不可写\n      canWrite = false;\n    }\n\n    return { defaultBranch, canRead, canWrite };\n  } catch (err: any) {\n    const status = err?.status || err?.response?.status;\n    if (status === 401) throw new Error(\"Token 无效或已过期（401）\");\n    if (status === 403) throw new Error(\"Token 权限不足或被禁止（403）。对于细粒度 token，请检查是否为该仓库授权。\");\n    if (status === 404) throw new Error(\"仓库不存在或 Token 未被授权访问该仓库（404）\");\n    throw new Error(`验证失败: ${err?.message ?? \"未知错误\"}`);\n  }\n}",
    "tags": [
      "Github",
      "readwrite"
    ],
    "createdAt": 1769266734241
  },
  {
    "id": "1769353733808",
    "title": "Zotero",
    "lang": "SQL",
    "code": "WITH RECURSIVE ancestors(itemID) AS (\n  SELECT i.itemID\n  FROM items i\n  WHERE i.itemTypeID = 3   -- attachment\n  -- 可改成只查一个特定 key\n  UNION ALL\n  SELECT ia.parentItemID\n  FROM itemAttachments ia\n  JOIN ancestors a ON ia.itemID = a.itemID\n  WHERE ia.parentItemID IS NOT NULL\n  UNION ALL\n  SELECT inote.parentItemID\n  FROM itemNotes inote\n  JOIN ancestors a ON inote.itemID = a.itemID\n)\nSELECT i.key AS ParentKey,\n       MAX(CASE WHEN f.fieldName='title' THEN idv.value END) AS title,\n       MAX(CASE WHEN f.fieldName='abstractNote' THEN idv.value END) AS abstract,\n       MAX(CASE WHEN f.fieldName='publicationTitle' THEN idv.value END) AS journal,\n       MAX(CASE WHEN f.fieldName='date' THEN idv.value END) AS date,\n       (SELECT GROUP_CONCAT(c.lastName || ', ' || c.firstName, '; ')\n        FROM itemCreators ic JOIN creators c ON ic.creatorID=c.creatorID\n        WHERE ic.itemID=i.itemID\n        ORDER BY ic.orderIndex) AS authors,\n       (SELECT GROUP_CONCAT(t.name,'; ')\n        FROM itemTags it JOIN tags t ON it.tagID=t.tagID\n        WHERE it.itemID=i.itemID) AS keywords\nFROM ancestors a\nJOIN items i ON i.itemID=a.itemID\nLEFT JOIN itemData id ON id.itemID=i.itemID\nLEFT JOIN fields f ON id.fieldID=f.fieldID\nLEFT JOIN itemDataValues idv ON id.valueID=idv.valueID\nWHERE i.itemTypeID NOT IN (3,40)\nGROUP BY i.key;\n",
    "tags": [
      "zotero"
    ],
    "createdAt": 1769353733808
  }
]