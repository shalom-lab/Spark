[
  {
    "id": "1769266734241",
    "title": "Githubæƒé™",
    "lang": "JS",
    "code": "import { Octokit } from \"@octokit/rest\";\n\nexport async function verifyGitHubAccessSimple(\n  repo: string,\n  token: string\n): Promise<{ defaultBranch: string; canRead: boolean; canWrite: boolean }> {\n  // å‚æ•°æ ¡éªŒï¼šowner/repo ä¸”éç©º\n  const parts = String(repo).split(\"/\").map(s => s.trim()).filter(Boolean);\n  if (parts.length !== 2) throw new Error('ä»“åº“æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º \"owner/repo\"');\n\n  const [owner, repoName] = parts;\n  if (!token || !token.trim()) throw new Error(\"ç¼ºå°‘ token\");\n\n  const octokit = new Octokit({ auth: token });\n\n  try {\n    const { data } = await octokit.rest.repos.get({ owner, repo: repoName });\n    const defaultBranch = data.default_branch ?? \"main\";\n\n    // ä¼˜å…ˆç”¨ data.permissionsï¼ˆå¦‚æœæœ‰ï¼‰\n    if (data.permissions) {\n      return {\n        defaultBranch,\n        canRead: Boolean(data.permissions.pull),\n        canWrite: Boolean(data.permissions.push || data.permissions.admin),\n      };\n    }\n\n    // å›é€€ç­–ç•¥ï¼ˆç®€æ´ç‰ˆï¼‰ï¼š\n    // 1) ç”¨ä¸€æ¬¡å®‰å…¨çš„åªè¯»è¯·æ±‚ç¡®è®¤ read èƒ½åŠ›\n    let canRead = false;\n    try {\n      await octokit.rest.repos.listBranches({ owner, repo: repoName, per_page: 1 });\n      canRead = true;\n    } catch {\n      canRead = false;\n    }\n\n    // 2) è‹¥èƒ½æ‹¿åˆ° authenticated userï¼Œåˆ™ä¿å®ˆæ¨æ–­ write\n    let canWrite = false;\n    try {\n      const me = await octokit.rest.users.getAuthenticated();\n      const username = me.data.login;\n      if (username) {\n        const perm = await octokit.rest.repos.getCollaboratorPermissionLevel({\n          owner,\n          repo: repoName,\n          username,\n        });\n        const level = perm.data.permission; // \"admin\" | \"write\" | \"read\" | \"none\"\n        canWrite = level === \"admin\" || level === \"write\";\n      }\n    } catch {\n      // æ— æ³•è·å– authenticated user æˆ–æƒé™æ¥å£å¤±è´¥ -> ä¿å®ˆè®¤ä¸ºä¸å¯å†™\n      canWrite = false;\n    }\n\n    return { defaultBranch, canRead, canWrite };\n  } catch (err: any) {\n    const status = err?.status || err?.response?.status;\n    if (status === 401) throw new Error(\"Token æ— æ•ˆæˆ–å·²è¿‡æœŸï¼ˆ401ï¼‰\");\n    if (status === 403) throw new Error(\"Token æƒé™ä¸è¶³æˆ–è¢«ç¦æ­¢ï¼ˆ403ï¼‰ã€‚å¯¹äºç»†ç²’åº¦ tokenï¼Œè¯·æ£€æŸ¥æ˜¯å¦ä¸ºè¯¥ä»“åº“æˆæƒã€‚\");\n    if (status === 404) throw new Error(\"ä»“åº“ä¸å­˜åœ¨æˆ– Token æœªè¢«æˆæƒè®¿é—®è¯¥ä»“åº“ï¼ˆ404ï¼‰\");\n    throw new Error(`éªŒè¯å¤±è´¥: ${err?.message ?? \"æœªçŸ¥é”™è¯¯\"}`);\n  }\n}",
    "tags": [
      "Github",
      "readwrite"
    ],
    "createdAt": 1769266734241
  },
  {
    "id": "1769353733808",
    "title": "Zotero",
    "lang": "SQL",
    "code": "WITH RECURSIVE ancestors(itemID) AS (\n  SELECT i.itemID\n  FROM items i\n  WHERE i.itemTypeID = 3   -- attachment\n  -- å¯æ”¹æˆåªæŸ¥ä¸€ä¸ªç‰¹å®š key\n  UNION ALL\n  SELECT ia.parentItemID\n  FROM itemAttachments ia\n  JOIN ancestors a ON ia.itemID = a.itemID\n  WHERE ia.parentItemID IS NOT NULL\n  UNION ALL\n  SELECT inote.parentItemID\n  FROM itemNotes inote\n  JOIN ancestors a ON inote.itemID = a.itemID\n)\nSELECT i.key AS ParentKey,\n       MAX(CASE WHEN f.fieldName='title' THEN idv.value END) AS title,\n       MAX(CASE WHEN f.fieldName='abstractNote' THEN idv.value END) AS abstract,\n       MAX(CASE WHEN f.fieldName='publicationTitle' THEN idv.value END) AS journal,\n       MAX(CASE WHEN f.fieldName='date' THEN idv.value END) AS date,\n       (SELECT GROUP_CONCAT(c.lastName || ', ' || c.firstName, '; ')\n        FROM itemCreators ic JOIN creators c ON ic.creatorID=c.creatorID\n        WHERE ic.itemID=i.itemID\n        ORDER BY ic.orderIndex) AS authors,\n       (SELECT GROUP_CONCAT(t.name,'; ')\n        FROM itemTags it JOIN tags t ON it.tagID=t.tagID\n        WHERE it.itemID=i.itemID) AS keywords\nFROM ancestors a\nJOIN items i ON i.itemID=a.itemID\nLEFT JOIN itemData id ON id.itemID=i.itemID\nLEFT JOIN fields f ON id.fieldID=f.fieldID\nLEFT JOIN itemDataValues idv ON id.valueID=idv.valueID\nWHERE i.itemTypeID NOT IN (3,40)\nGROUP BY i.key;\n",
    "tags": [
      "zotero"
    ],
    "createdAt": 1769353733808
  },
  {
    "id": "1769408828549",
    "title": "Zotero",
    "lang": "JS",
    "code": "(async function() {\n\n    const SEARCH_NAME = 'é‡å¤æ¡ç›® (_dup)';\n\n    // è·å–å½“å‰ä¸ªäººåº“çš„ ID\n\n    const libID = Zotero.Libraries.userLibraryID;\n\n\n\n    // ä¿®å¤ç‚¹ï¼šä¼ å…¥ libIDï¼Œè§£å†³ SQL å ä½ç¬¦æŠ¥é”™\n\n    let allSearches = await Zotero.Searches.getAll(libID);\n\n    \n\n    let foundSearch = allSearches.find(s => s.getName() === SEARCH_NAME);\n\n\n\n    if (foundSearch) {\n\n        console.log(`ğŸ” æ‰¾åˆ° Key: ${foundSearch.key}`);\n\n        \n\n        // æ‰§è¡Œç‰©ç†åˆ é™¤\n\n        await foundSearch.eraseTx();\n\n        \n\n        // åˆ·æ–° UI\n\n        if (typeof ZoteroPane !== 'undefined') {\n\n            ZoteroPane.collectionsView.refresh();\n\n        }\n\n        \n\n        return `æˆåŠŸåˆ é™¤: ${SEARCH_NAME}`;\n\n    } else {\n\n        return \"æœªæ‰¾åˆ°è¯¥æœç´¢åˆ†ç±»\";\n\n    }\n\n})();",
    "tags": [
      "search"
    ],
    "createdAt": 1769408828549
  }
]